# First arrival traveltime tomography Documentation

>First arrival traveltime tomography is a geophysical imaging technique used to map the subsurface velocity structure of the Earth. It relies on the measurement of travel times of seismic waves that are first to arrive at seismic stations after being generated by a source. By analyzing these travel times, scientists can infer variations in the velocity of seismic waves, which in turn provides insights into the properties and structures of the subsurface materials. This method is particularly useful for near-surface imaging and has applications in fields such as earthquake seismology, exploration geophysics, and environmental studies. The technique involves creating an initial velocity model, performing forward modeling to predict travel times, and then iteratively updating the model based on the differences between observed and predicted travel times. 
This documentation aims to help users understand our implementation process for solving **medium-scale** geophysical inverse problems. For large-scale inverse problems, you can refer to the full waveform inversion demo (fwi) included in our packages, which will guide you on how to organize the optimization workflow and submit jobs to an HPC cluster. The optimization toolbox [optim](https://github.com/beyondTaoLei/optim) has been developed by Tao Lei (leit@sustech.edu.cn) and Wei Zhang (zhangwei@sustech.edu.cn). If you encounter any issues while using this software, please do not hesitate to contact us.
***

## 0. Demo structure
The root directory contains several key components essential for understanding and utilizing the provided resources. It includes this documentation, the workflow example (**case1**), the collection of main functions (**prob**), and some drawing scripts located in **plot**. 

Most parameters will be set using the script **S0_prepare.py** within the workflow example(**case1**). The following directory tree presents the main structure for solving first arrival traveltime tomography problem:

```
|-- README.md                   >>> this documentation
|-- case1                       >>> workflow example
|   |-- P0_prepare_files.py     
|   |-- P1_generate_data.py
|   |-- P2_generate_Mweight.py
|   |-- S0_prepare.py
|   |-- S1_optim_LSQR.py
|   |-- S1_optim_PLCG.py
|   `-- S2_run.py
|-- plot                        >>> figure presentation
|   |-- plot_mod.py
|   |-- plot_raypath.py
|   |-- plot_misfit.py
`-- prob                        >>> main functions used in workflow
    |-- forward2d.py
    |-- calc_diff_sensmat.py
    |-- media_fd2inv.py
    |-- update_model.py
    |-- update_optim.py
    |-- check_stopping.py
    `-- util.py

      Figure 1. The structure of first arrival tomography demo
```

## 1. Configure environment

To ensure that your software runs smoothly, you need to install the required Python libraries. Below are the steps to install *matplotlib* and other dependencies using *conda*:

- Create a new environment (optional): It is a good practice to create and use a virtual environment to manage dependencies. Replace *myenv* with your desired environment name.
  ```sh
  conda create -n myenv
  conda activate myenv
  ```
- Install dependencies: Use the following command to install the required libraries.
  ```sh
  conda install -c conda-forge numpy scipy pandas matplotlib
  ```
- List installed libraries: To verify that the libraries are installed successfully, you can list the installed packages
  ```sh
  conda list
  ```
By following these steps, you ensure that all necessary packages are installed and your Python environment is set up properly.

## 2. Prepare observed data

- Specify the path to the tomography demo and name your project in the terminal
  ```sh
  demoroot=/path/to/software/optim/demo/firstarrival
  mkdir prj
  cd prj
  ```
  Here, **demoroot** indicates the root path of the example codes. Specifying this path in the terminal will facilitate copying and using the subsequent codes for study.

- Modify the program path variables in the script **${demoroot}/case1/S0_prepare.py**  
  ```sh
  'Program path'      :'comment',
  'optimroot'         :'/path/to/software/optim',
  ```

- Write the global parameters for the whole project
  ```sh
  python ${demoroot}/case1/S0_prepare.py optim
  ```
  :bell: Output: **optim/optim.json**
  We place all optimization parameters in the script **S0_prepare.py**. Each program in the inverse workflow will extract the necessary parameters from the output JSON file. The input parameter **optim** in the command specifies the output folder to store the model, misfit function, and other files for each iteration.

- Copy the models from the *optim* package into the current project directory, distribute the true model to a specific location, and display the model as
  ```sh
  cp -r ${demoroot}/case1/model .
  cp model/true/true.vp model/inv/inv.vp
  python ${demoroot}/plot/plot_mod.py optim model/inv/inv.vp
  ```
  :bell: Output: **model/inv/inv.vp**

- Prepare the geometry for the current study, which includes 40 sources and 160 receivers located on the surface
  ```sh
  python ${demoroot}/case1/P0_prepare_files.py
  ``` 
  | Target          | :bell: Output |
  | ------          | ------ |
  | source          | **list/src.csv** |
  | receiver        | **fdio/srcname/receiver.csv** |
  
  where the output file **list/src.csv** contains the positions of all sources, and each source's geometry configuration file **receiver.csv** is distributed to a subfolder named after the source, such as, *srcname*.

- Generate the observed data for all sources
  ```sh
  # first generate the commands
  python ${demoroot}/case1/P1_generate_data.py optim
  # and then execute with multiple processors
  python ${demoroot}/case1/S2_run.py optim
  ```
  | Target              | :bell: Output |
  | ------              | ------ |
  | job list            | **job/job.csv** |
  | traveltime field    | **fdio/srcname/timefield.bin** |
  | observed traveltime | **fdio/srcname/obs.csv** |
  | raypath             | **fdio/srcname/raypath.dat** |
  
  where the first script will generate the forward modeling commands and store them in the file **job/job.csv**, while the second script will execute these commands and generate the traveltime field, observed time and associated raypaths. Note that calculating the travel times may take a few minutes.

- Display the raypath for one shot, such as sz001
  ```sh
  python ${demoroot}/plot/plot_raypath.py optim fdio/sz001/raypath.dat
  ```

## 3. Run inverse workflow

- Prepare the initial model to start the inversion process
  ```sh
  cp model/init/init.vp model/inv/inv.vp
  ```
  :bell: Output: **model/inv/inv.vp**

- Write the global parameters for the whole project
  ```sh
  python ${demoroot}/case1/S0_prepare.py LSQR
  ```
  :bell: Output: **LSQR/optim.json**
  
- Prepare the model weighting files, where the shallow water layer is ignored during the inversion process
  ```sh
  python ${demoroot}/case1/P2_generate_Mweight.py LSQR
  ```
  :bell: Output: **list/wgtm.npz**

- Generate the LSQR workflow from iteration 1 to 20, and then execute the workflow
  ```sh
  # generate the commands
  python ${demoroot}/case1/S1_optim_LSQR.py LSQR 1 20
  # execute with multiple processors
  python ${demoroot}/case1/S2_run.py LSQR
  ```
  | Target              | :bell: Output |
  | ------              | ------ |
  | job list            | **job/job.csv** |
  | evaluated model     | **LSQR/iter#/modg.bin** |
  | time difference     | **LSQR/iter#/diff.dat** |
  | data misfit         | **LSQR/iter#/fcost.dat** |

  where the file **modg.bin** represents the evaluated model at the **#**-th iteration. The file **diff.dat** contains a list of time differences between the synthetic and observed traveltimes, and **fcost.dat** represents the total data misfit.

- Display the inverse result using the LSQR approach
  ```sh
  python ${demoroot}/plot/plot_mod.py LSQR LSQR/iter20/modg.bin
  ```

- Display the evolution of the misfit function
  ```sh
  python ${demoroot}/plot/plot_misfit.py LSQR
  ```

- Test PLCG optimization method in the same way (_optional_)
  ```sh
  # linear conjugate gradient
  cp model/init/init.vp model/inv/inv.vp
  python ${demoroot}/case1/S0_prepare.py PLCG
  python ${demoroot}/case1/S1_optim_PLCG.py PLCG 1 20
  python ${demoroot}/case1/S2_run.py PLCG
  python ${demoroot}/plot/plot_mod.py PLCG PLCG/iter20/modg.bin
  python ${demoroot}/plot/plot_misfit.py PLCG
  ```
  where the parameter **PLCG** following the commands specifies a folder used to store the results from each iteration.

## 4. Set json Parameters

In this section, we will discribe how to set the parameters in the configuration JSON file. The final file should include the following key components: 1) program path module, 2) file path information, 3) forward modeling module, 4) descent direction module, 5) model update module, 6) inversion loop. We will go over each of these components in detail.

### 4.1 Program path module
  Since we run all commands from the project root path, we need to define the location of the optimization toolbox. The following parameter is required:
  ```sh
  'Program path'      :'comment',
  'optimroot'         :'/path/to/software/optim',

  ```
  **Parameters**
  - ***optimroot: string*** 
  The root path to the optimization toolbox codes. 

### 4.2 File path information
  We build the inverse workflow with a series of procedures, including the geophysical modules and the optimization modules, and each procedure connects the predecessors and successors with files. Therefore, it is necessary to specify the locations of the model, cost function, sensitivity matrix, and other relevant files. The contents of these files may be updated over iterations.
  ```sh
  'File path'         :'comment',
  'fsrc'              :'list/src.csv',
  'fmodfd'            :'model/inv/inv.vp',                # input for FD modeling
  'fmodfdref'         :'model/inv/ref.vp',
  'fmod'              :'model/inv/inv_tomo.slowness',     # optim needs
  'fmodref'           :'model/inv/ref_tomo.slowness',     # optim needs
  'fcost'             :'list/fcost.dat',                  # optim needs
  'fdiff'             :'list/diff.dat',                   # optim needs
  'fsensmat'          :'list/sensmat.npz'                 # optim needs
  'fwgtm'             :'list/wgtm.npz',                   # optim needs
  'fwgtd'             :'list/wgtd.npz',                   # optim needs
  ```
  **Parameters**
  - ***fsrc: input, string***
    The path for storing the source information, where the data is saved in *csv* format. The key 'station' in the header indicates the source name, while 'x' and 'y' indicate the coordinates of the source.
  - ***fmodfd: input&output, string***
    The path for storing the current model for traveltime calculation, where the data is saved in a 32-bit floating-point binary file. The input data is arranged in *column-major* order, with the coordinate origin at the top-left corner. The x-axis extends to the right, and the y-axis extends downward.
  - ***fmodfdref: optional input, string***
    Similar to ***fmodfd***, but the associated model is used as the reference model when the inversion seeks the smoothest model (***modeltype***=3).
  - ***fmod: output, string***
    The path for storing the resampled output of the model is within the file ***fmodfd***, with a shape of (M, 1).
  - ***fmodref: output, string***
    The path for storing the resampled output of the model is within the file ***fmodfdref***, with a shape of (M, 1).
  - ***fcost: output, string***
    The path for storing the misfit function, where the data is saved in *ASCII* floating-point type.
  - ***fdiff: output, string***
    The path for storing the measurement difference, where the data is saved in *ASCII* floating-point format, with a shape of (N, 1).
  - ***fsensmat: output, string***
    The path for storing the sensitivity matrix, where the data is saved as a sparse matrix with a shape of (N, M).
  - ***fwgtm: optional input, string***
    The path for storing the model weighting, where the data is saved as a compressed archive file in the format *.npz*. The data is a sparse diagonal matrix with a shape of (M, M).
  - ***fwgtd: optional input, string***
    The path for storing the data weighting, where the data is saved as a compressed archive file in the format *.npz*. The data is a sparse diagonal matrix with a shape of (N, N).

### 4.3 Forward modeling module
  Next, we will detail the parameters specifically for travel time and sensitivity calculations. 
  ```sh
  'Forward part'      :'comment',
  'ncores'            :8,
  'nxyfd'             :[680, 155],
  'oxyfd'             :[0.0, 0.0],
  'dxyfd'             :[25.0, 25.0],
  'incxy'             :[2, 2],
  ```
  **Parameters**
  - ***ncores: int***
    The number of cores for travel time calculation, We split the modeling tasks into **ncores** jobs and then submit them simultaneously using bash scripts.
  - ***nxyfd: list of int***
    The number of grid points in the x- and y-directions for forward modeling, respectively.
  - ***oxyfd: list of float***
    The original coordinates of the input model in the x- and y-directions for forward modeling, respectively.
  - ***dxyfd: list of float***
    The grid spacing of the input model in the x- and y-directions for forward modeling, respectively.
  - ***incxy: list of int***
    The sampling interval number in the x- and y-directions, respectively, for saving the sensitivity matrix.

### 4.4 Descent direction module
  For most optimization algorithms, users need to input few additional parameters to constrain the calculation of the descent direction. Here, we will introduce the basic parameters for linear optimization methods in the *OPTIM* software. You can select the **LSQR** or Preconditioned Linear Conjugate Gradient (**PLCG**) method to build your inverse workflow. In cases where the linear system is ill-posed or nearly singular, a regularization term can help stabilize the solutions by adding a controlled amount of bias, leading to more robust estimates. There are three types of regularization term to choose from, and more details can be found later.
  ```sh
  'Descent part'      :'comment',
  'modeltype'         :3,             # optim needs                
  'descent_type'      :1,             # optim needs            
  'precond'           :1,             # optim needs            
  'niter_inner_max'   :100,           # optim needs           
  'lambda0'           :10000.0,       # optim needs                
  ```
  **Parameters**
  - ***modeltype: int***
    The desired model type one may look for, 1: the smoothest model, 2: the flattest model, 3: the smallest perturbation model.
  - ***descent_type: int***
    The descent perturbation type when solving the linear equation. 1 indicates the absolute perturbation; 2 indicates the relative perturbation. 
  - ***precond: optional, int***
    Whether to apply a preconditioning operator for the linear conjugate gradient method. 1 means yes; 0 means no.
  - ***niter_inner_max: int***
    The maximum number of iterations for **PLCG** or **LSQR** loop.
  - ***lambda0: float***
    The regularization parameter is used to balance the data misfit and model misfit. The users typically need to make numerous attempts to identify the optimal parameters.

### 4.5 Model update module
  Once the descent direction $p_k$ is generated by the above linear optimization algorithms, we will update the model by a fixed percentage. The relevant parameters are as follows,
  ```sh
  'Update part'       :'comment',
  'eps_scale'         :0.02,                      
  'smooth_size'       :[150.0, 150.0],            
  'mod_limits'        :1,                         
  'mod_lb'            :1500,                      
  'mod_ub'            :4800,                      
  ```
  **Parameters**
  - ***eps_scale: float***
    The percentage by which the model is updated relative to its current state.
  - ***smooth_size: list of float*** 
    The smoothing size in the x and y directions for the descent direction, measured in meters.
  - ***mod_limits: int***
    Whether to check the bounds of model value. 1 means yes; 0 means no.
  - ***mod_lb: float***  
    Lower limit of model value, set according to the prior information of the model.
  - ***mod_ub: float***  
    Upper limit of model value, set according to the prior information of the model.

### 4.6 Inversion loop
  Assume that the inversion task has multiple stages, users need to specify the starting iteration, abort criteria, and so on.
  ```sh
  'Inversion loop'    :'comment',
  'abort'             :0, 
  'iter0'             :1,         # optim needs         
  'niter_min'         :15,        # optim needs
  'niter_max'         :80,        # optim needs
  'pro'               :0.01,
  'pro2'              :0.01,
  'pro3'              :0.01,
  ```
  **Parameters**
  - ***abort: int***
    The initial status for the inverse workflow. The value 0 is required when updating the configuration JSON file using the script **S0_prepare.py**; the value 1 indicates that one abort criterion has been met.
  - ***iter0: int***
    The initial iteration number for the current inversion stage/phase.
  - ***niter_min: int***
    The minimum number of iterations.
  - ***niter_max: int***
    The maximum number of iterations, for future design.
  - ***pro: int***
    The convergence threshold. The inversion will terminate when the relative reduction in the misfit function $\frac{E_{i-2}-E_{i}}{E_{i-2}}$ falls below this threshold, where $E_{i}$ means the misfit function at *i*th iteration.
  - ***pro2: int***
    The slope convergence threshold. The inversion will terminate when the change rate in the misfit function slope $\frac{k_{i}}{k_{0}}$ falls below this threshold, where $k_{i}$ means the misfit function slope at *i*th iteration.
  - ***pro3: int***
    The average convergence threshold. The inversion will terminate when the average value of the misfit function over nearby iterations $\frac{ave_{i}}{ave_{0}}$ falls below this threshold, where $ave_{i}$ means the average of misfit function around *i*th iteration.

